// Generated by CoffeeScript 1.6.2
var COMMANDS, COMMAND_NAMES, CONTEXTS, DEBUG, DEFAULTS, KEYS, Session, SessionList, apply_to_matching_tabs, apply_to_regex_tabs, c, cmd, context, d, f, kill, main_choice, main_i, name, open_session, prepare, reload_window, reverse, save_session, sentence_case, sessions, tab_open, window, _i, _len, _ref, _ref1,
  __slice = [].slice,
  __hasProp = {}.hasOwnProperty,
  __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };

window = {};

f = {};

DEBUG = true;

d = function() {
  var s, ss, _i, _len, _results;

  ss = 1 <= arguments.length ? __slice.call(arguments, 0) : [];
  if (DEBUG) {
    _results = [];
    for (_i = 0, _len = ss.length; _i < _len; _i++) {
      s = ss[_i];
      _results.push(console.log(s));
    }
    return _results;
  }
};

main_i = -1;

main_choice = -1;

tab_open = function(url) {
  return chrome.tabs.create({
    url: url
  });
};

sentence_case = function(s) {
  var i, ret;

  ret = s[0].toUpperCase() + s.slice(1).toLowerCase();
  while ((i = ret.indexOf('_')) > 0) {
    ret = ret.slice(0, +(i - 1) + 1 || 9e9) + ' ' + s[i + 1].toUpperCase() + s.slice(i + 2).toLowerCase();
  }
  return ret;
};

Session = (function(_super) {
  __extends(Session, _super);

  function Session() {
    _ref = Session.__super__.constructor.apply(this, arguments);
    return _ref;
  }

  return Session;

})(Backbone.Model);

SessionList = (function(_super) {
  __extends(SessionList, _super);

  function SessionList() {
    _ref1 = SessionList.__super__.constructor.apply(this, arguments);
    return _ref1;
  }

  SessionList.prototype.model = Session;

  SessionList.prototype.localStorage = new Backbone.LocalStorage('sessions');

  SessionList.prototype.get_by_name = function(name) {
    return this.each(function(s) {
      if (s.get('name') === name) {
        return s;
      }
    });
  };

  return SessionList;

})(Backbone.Collection);

sessions = new SessionList;

reverse = function(h) {
  var k, o, v;

  o = {};
  for (k in h) {
    v = h[k];
    o[v] = sentence_case(k);
  }
  return o;
};

KEYS = {
  CODES: {
    RETURN: 13,
    ESC: 27,
    SPACE: 32,
    PAGE_UP: 33,
    PAGE_DOWN: 34,
    END: 35,
    HOME: 36,
    LEFT: 37,
    UP: 38,
    RIGHT: 39,
    DOWN: 40
  }
};

KEYS.NAMES = reverse(KEYS.CODES);

CONTEXTS = {
  TAB: 0,
  EXTENSION: 1,
  APP: 2,
  SESSION: 3,
  TEXT: 4,
  SPECIAL: 5,
  BOOKMARK: 6,
  MAIN: 7,
  COMMAND: 8
};

COMMANDS = {
  duplicate: {
    desc: 'Duplicate tab',
    context: [CONTEXTS.TAB, CONTEXTS.MAIN],
    fn: function(tab) {
      return chrome.tabs.create(_.copy(tab, 'windowId', 'index', 'url'));
    }
  },
  reload_all_tabs: {
    desc: 'Reload every tab in every window',
    context: CONTEXTS.MAIN,
    fn: function(x) {
      return chrome.windows.getAll({
        populate: true
      }, function(wins) {
        var win, _i, _len, _results;

        _results = [];
        for (_i = 0, _len = wins.length; _i < _len; _i++) {
          win = wins[_i];
          _results.push(reload_window(win));
        }
        return _results;
      });
    }
  },
  reload_all_tabs_in_window: {
    desc: 'Reload every tab in this window',
    context: CONTEXTS.MAIN,
    fn: function(x) {
      return chrome.windows.getCurrent(function(win) {
        return reload_window(win);
      });
    }
  },
  search_history: {
    desc: 'Search through your history for the given text',
    context: CONTEXTS.TEXT,
    fn: function(text) {
      return tab_open('chrome://history/#q=' + text + '&p=0');
    }
  },
  extract: {
    desc: "Extract tabs that match the given text or the given tab's domain into a new window",
    context: [CONTEXTS.TEXT, CONTEXTS.MAIN, CONTEXTS.TAB],
    fn: function(text) {
      return apply_to_matching_tabs(text, function(tabs) {
        var _this = this;

        return chrome.windows.create({
          focused: true,
          tabId: tabs[0].id
        }, function(win) {
          var i, _i, _ref2, _results;

          _results = [];
          for (i = _i = 1, _ref2 = tabs.length; 1 <= _ref2 ? _i <= _ref2 : _i >= _ref2; i = 1 <= _ref2 ? ++_i : --_i) {
            _results.push(chrome.tabs.move(tabs[i].id, {
              windowId: win.id,
              index: 0
            }));
          }
          return _results;
        });
      });
    }
  },
  close: {
    desc: "Close tabs that match the given text or the given tab's domain",
    context: [CONTEXTS.TEXT, CONTEXTS.MAIN, CONTEXTS.TAB],
    fn: function(text) {
      return apply_to_matching_tabs(text, function(tabs) {
        var tab, _i, _len, _results;

        _results = [];
        for (_i = 0, _len = tabs.length; _i < _len; _i++) {
          tab = tabs[_i];
          _results.push(chrome.tabs.remove(tab.id));
        }
        return _results;
      });
    }
  },
  kill: {
    desc: "Kill tabs that match the given text or the given tab's domain",
    context: [CONTEXTS.TEXT, CONTEXTS.MAIN, CONTEXTS.TAB],
    fn: function(text) {
      return apply_to_matching_tabs(text, function(tabs) {
        var tab, _i, _len, _results;

        _results = [];
        for (_i = 0, _len = tabs.length; _i < _len; _i++) {
          tab = tabs[_i];
          _results.push(kill(tab.id));
        }
        return _results;
      });
    }
  },
  kill_all: {
    desc: 'Kill all tabs',
    context: CONTEXTS.MAIN,
    fn: function(x) {
      return chrome.windows.getAll({
        populate: true
      }, function(wins) {
        var tab, win, _i, _len, _results;

        _results = [];
        for (_i = 0, _len = wins.length; _i < _len; _i++) {
          win = wins[_i];
          _results.push((function() {
            var _j, _len1, _ref2, _results1;

            _ref2 = win.tabs;
            _results1 = [];
            for (_j = 0, _len1 = _ref2.length; _j < _len1; _j++) {
              tab = _ref2[_j];
              _results1.push(kill(tab.id));
            }
            return _results1;
          })());
        }
        return _results;
      });
    }
  },
  pin: {
    desc: 'Pin tab',
    context: [CONTEXTS.TAB, CONTEXTS.MAIN],
    fn: function(tab) {
      return chrome.tabs.update(tab.id, {
        pinned: true
      });
    }
  },
  unpin: {
    desc: 'Unpin tab',
    context: [CONTEXTS.TAB, CONTEXTS.MAIN],
    fn: function(tab) {
      return chrome.tabs.update(tab.id, {
        pinned: false
      });
    }
  },
  select: {
    desc: 'Select tab',
    context: CONTEXTS.TAB,
    fn: function(tab) {
      return chrome.tabs.update(tab.id, {
        selected: true
      });
    }
  },
  enable: {
    desc: 'Enable extension or app',
    context: [CONTEXTS.EXTENSION, CONTEXTS.APP],
    fn: function(ext) {
      return chrome.management.setEnabled(ext.id, true);
    }
  },
  disable: {
    desc: 'Disable extension or app',
    context: [CONTEXTS.EXTENSION, CONTEXTS.APP],
    fn: function(ext) {
      return chrome.management.setEnabled(ext.id, false);
    }
  },
  options: {
    desc: 'Open the options page of an extension or app',
    context: [CONTEXTS.EXTENSION, CONTEXTS.APP],
    fn: function(ext) {
      return tab_open(ext.optionsUrl);
    }
  },
  describe: {
    desc: 'Show description of extension or app',
    context: [CONTEXTS.EXTENSION, CONTEXTS.APP],
    fn: function(ext) {
      return alert(ext.description + ' -- Version: ' + ext.version);
    }
  },
  homepage: {
    desc: 'Open homepage of extension or app',
    context: [CONTEXTS.EXTENSION, CONTEXTS.APP],
    fn: function(ext) {
      return tab_open(ext.homepageUrl);
    }
  },
  launch: {
    desc: 'Launch app',
    context: CONTEXTS.APP,
    fn: function(app) {
      return chrome.management.launchApp(app.id);
    }
  },
  uninstall: {
    desc: 'Uninstall extension or app',
    context: [CONTEXTS.EXTENSION, CONTEXTS.APP],
    fn: function(ext) {
      return chrome.management.uninstall(ext.id);
    }
  },
  add: {
    desc: 'Add current tab to session',
    context: CONTEXTS.SESSION,
    fn: function(session) {
      var _this = this;

      return chrome.tabs.getCurrent(function(tab) {
        var s, wins;

        s = sessions.get_by_name(session.name);
        wins = s.get('wins');
        wins[0].url.push(tab.url);
        wins[0].pins.push(tab.pinned);
        return s.save({
          wins: wins
        });
      });
    }
  },
  save: {
    desc: 'Save the current window with the name given',
    context: CONTEXTS.TEXT,
    fn: function(name) {
      var _this = this;

      return chrome.windows.getCurrent(function(win) {
        return save_session(name, [prepare(win)]);
      });
    }
  },
  save_all: {
    desc: 'Save all open windows with the name given',
    context: CONTEXTS.TEXT,
    fn: function(name) {
      var _this = this;

      return chrome.windows.getAll({
        populate: true
      }, function(wins) {
        var win, _i, _len, _results;

        _results = [];
        for (_i = 0, _len = wins.length; _i < _len; _i++) {
          win = wins[_i];
          _results.push(save_session(name, prepare(win)));
        }
        return _results;
      });
    }
  },
  open: {
    desc: 'Open saved session, bookmark, or special page',
    context: [CONTEXTS.SESSION, CONTEXTS.SPECIAL, CONTEXTS.BOOKMARK],
    fn: function(page) {
      var folder;

      if (page.wins) {
        return open_session(page);
      } else if (page.url) {
        return tab_open(page.url);
      } else {
        folder = page;
        return chrome.bookmarks.getChildren(folder.id, function(pages) {
          var _i, _len, _results;

          if (pages.length > 20) {
            if (!confirm("Open all " + pages.length + " tabs in bookmark folder?")) {
              return;
            }
          }
          _results = [];
          for (_i = 0, _len = pages.length; _i < _len; _i++) {
            page = pages[_i];
            _results.push(tab_open(page.url));
          }
          return _results;
        });
      }
    }
  },
  "delete": {
    desc: 'Delete session or bookmark',
    context: [CONTEXTS.SESSION, CONTEXTS.BOOKMARKS],
    fn: function(bookmark) {
      if (bookmark.wins) {
        return sessions.get_by_name(bookmark.name).destroy();
      } else if (bookmark.children && bookmark.children.length !== 0) {
        if (confirm("Recursively delete all " + bookmark.children.length + " bookmarks in folder?")) {
          return chrome.bookmarks.removeTree(bookmark.id);
        }
      } else {
        return chrome.bookmarks.remove(bookmark.id);
      }
    }
  }
};

DEFAULTS = {
  0: COMMANDS.select,
  1: COMMANDS.options,
  2: COMMANDS.launch,
  3: COMMANDS.restore,
  4: COMMANDS.history,
  5: COMMANDS.open,
  6: COMMANDS.open,
  7: null,
  8: null
};

COMMAND_NAMES = [];

for (name in COMMANDS) {
  cmd = COMMANDS[name];
  context = cmd.context;
  if (!(context instanceof Array)) {
    context = [context];
  }
  for (_i = 0, _len = context.length; _i < _len; _i++) {
    c = context[_i];
    COMMAND_NAMES[c] || (COMMAND_NAMES[c] = []);
    COMMAND_NAMES[c].push({
      name: sentence_case(name),
      cmd: cmd
    });
  }
}

prepare = function(win) {
  return _.extend(_.copy(win, 'left', 'top', 'width', 'height', 'focused'), {
    urls: _(win.tabs).pluck('url'),
    pins: _(win.tabs).pluck('pinned'),
    icons: _(win.tabs).pluck('favIconUrl')
  });
};

apply_to_matching_tabs = function(text, fn) {
  var domain, http, tab;

  if (text.url) {
    tab = text;
    if (_(tab.url).startsWith('chrome' || _(tab.url).startsWith('about'))) {
      return apply_to_regex_tabs(/^(chrome|about)/, fn);
    } else {
      http = '^https*://';
      domain = tab.url.match(new RegExp(http + '(.*\..{2,4}/)', 'i'))[1];
      if (domain) {
        return apply_to_regex_tabs(new RegExp(http + domain, 'i'), fn);
      }
    }
  } else {
    return apply_to_regex_tabs(new RegExp(text, 'i'), fn);
  }
};

apply_to_regex_tabs = function(regex, fn) {
  var tabs,
    _this = this;

  tabs = get_tabs(regex);
  return chrome.windows.getAll({
    populate: true
  }, function(wins) {
    var tab, win, _j, _len1, _ref2;

    _ref2 = _.flatten((function() {
      var _k, _len1, _results;

      _results = [];
      for (_k = 0, _len1 = wins.length; _k < _len1; _k++) {
        win = wins[_k];
        _results.push(win.tabs);
      }
      return _results;
    })());
    for (_j = 0, _len1 = _ref2.length; _j < _len1; _j++) {
      tab = _ref2[_j];
      if (regex.test(tab.url)) {
        tabs = tab;
      }
    }
    return fn(tabs);
  });
};

open_session = function(session) {
  var win, _j, _len1, _ref2, _results,
    _this = this;

  _ref2 = session.wins;
  _results = [];
  for (_j = 0, _len1 = _ref2.length; _j < _len1; _j++) {
    win = _ref2[_j];
    win.url = win.urls.toString();
    _results.push(chrome.windows.create(win, function(new_win) {
      var i, _k, _ref3, _results1;

      _results1 = [];
      for (i = _k = 0, _ref3 = win.tabs.length; 0 <= _ref3 ? _k < _ref3 : _k > _ref3; i = 0 <= _ref3 ? ++_k : --_k) {
        _results1.push(chrome.tabs.update(new_win.tabs[i].id, {
          pinned: win.pins[i]
        }));
      }
      return _results1;
    }));
  }
  return _results;
};

save_session = function(name, wins) {
  var s;

  s = new Session({
    name: name,
    wins: wins
  });
  sessions.add(s);
  return s.save();
};

reload_window = function(win) {
  var tab, _j, _len1, _ref2, _results;

  _ref2 = win.tabs;
  _results = [];
  for (_j = 0, _len1 = _ref2.length; _j < _len1; _j++) {
    tab = _ref2[_j];
    _results.push(chrome.tabs.update(tab.id, {
      url: tab.url
    }));
  }
  return _results;
};

kill = function(id) {
  return chrome.tabs.update(id, {
    url: 'about:kill'
  });
};

window._.copy = function() {
  var key, keys, o, ret, _j, _len1;

  o = arguments[0], keys = 2 <= arguments.length ? __slice.call(arguments, 1) : [];
  ret = {};
  for (_j = 0, _len1 = keys.length; _j < _len1; _j++) {
    key = keys[_j];
    ret[key] = o[key];
  }
  return ret;
};
